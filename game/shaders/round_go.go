// Code generated by file2byteslice. DO NOT EDIT.

package shaders

var Round = []byte("// snake-ebiten\n// Copyright (C) 2022 Anıl Konaç\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n//go:build ignore\n\npackage main\n\nvar Color vec4\nvar ShadedCorners [4]float\nvar RectSize vec2\nvar RectPosInUnit vec2\nvar TotalSize vec2\nvar IsVertical float\n\nfunc Fragment(position vec4, texCoord vec2, color vec4) vec4 {\n\tnormColor := Color / 0xffff\n\n\tposInUnit := vec2(RectSize.x*texCoord.x, RectSize.y*texCoord.y) + RectPosInUnit\n\tif IsVertical > 0 {\n\t\tradius := TotalSize.x / 2.0\n\n\t\t// Top Left Corner\n\t\tif roundMult := ShadedCorners[0]; (roundMult > 0) && (posInUnit.x < radius) && (posInUnit.y < radius) { // In point is on top left corner\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.y < growUp(posInUnit.x, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Bottom Left Corner\n\t\tif roundMult := ShadedCorners[1]; (roundMult > 0) && (posInUnit.x < radius) && (posInUnit.y > (TotalSize.y - radius)) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.y > growDown(posInUnit.x, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Bottom Right Corner\n\t\tif roundMult := ShadedCorners[2]; (roundMult > 0) && (posInUnit.x > radius) && (posInUnit.y > (TotalSize.y - radius)) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.y > growDown(posInUnit.x, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Top Right Corner\n\t\tif roundMult := ShadedCorners[3]; (roundMult > 0) && (posInUnit.x > radius) && (posInUnit.y < radius) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.y < growUp(posInUnit.x, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\t// if TotalSize.x >= TotalSize.y {\n\t\tradius := TotalSize.y / 2.0\n\n\t\t// Top Left Corner\n\t\tif roundMult := ShadedCorners[0]; (roundMult > 0) && (posInUnit.x < radius) && (posInUnit.y < radius) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.x < growLeft(posInUnit.y, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Bottom Left Corner\n\t\tif roundMult := ShadedCorners[1]; (roundMult > 0) && (posInUnit.x < radius) && (posInUnit.y > radius) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.x < growLeft(posInUnit.y, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Bottom Right Corner\n\t\tif roundMult := ShadedCorners[2]; (roundMult > 0) && (posInUnit.x > TotalSize.x-radius) && (posInUnit.y > radius) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.x > growRight(posInUnit.y, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t\t// Top Right Corner\n\t\tif roundMult := ShadedCorners[3]; (roundMult > 0) && (posInUnit.x > TotalSize.x-radius) && (posInUnit.y < radius) {\n\t\t\tmultiplier := 1.0\n\t\t\tif (roundMult > 1.0) && (roundMult <= 2) {\n\t\t\t\tmultiplier = 1.0 + (sqrt(2.0)-1.0)*easeOutCirc(roundMult-1.0)\n\t\t\t}\n\t\t\tif posInUnit.x > growRight(posInUnit.y, radius, multiplier) {\n\t\t\t\tnormColor.a = 0.0\n\t\t\t}\n\t\t}\n\t}\n\n\tnormColor.rgb *= normColor.a\n\treturn normColor\n}\n\nfunc growUp(x, radius, multiplier float) float {\n\treturn radius - sqrt(pow(radius*multiplier, 2.0)-pow(x-radius, 2.0))\n}\n\nfunc growDown(x, radius, multiplier float) float {\n\treturn TotalSize.y - radius + sqrt(pow(radius*multiplier, 2.0)-pow(x-radius, 2.0))\n}\n\nfunc growLeft(y, radius, multiplier float) float {\n\treturn radius - sqrt(pow(radius*multiplier, 2.0)-pow(y-radius, 2.0))\n}\n\nfunc growRight(y, radius, multiplier float) float {\n\treturn TotalSize.x - radius + sqrt(pow(radius*multiplier, 2.0)-pow(y-radius, 2.0))\n}\n\n// Taken from https://easings.net/#easeOutCirc\nfunc easeOutCirc(x float) float {\n\treturn sqrt(1.0 - pow(x-1.0, 2.0))\n}\n")
