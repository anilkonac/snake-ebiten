// Code generated by file2byteslice. DO NOT EDIT.

package shaders

var Round = []byte("// Copyright (c) 2022 Anıl Konaç\n// This file is licensed under the MIT license.\n\n//go:build ignore\n\npackage main\n\nvar Color vec4\nvar ShadedCorners [4]float\nvar RectSize vec2\nvar RectPosInUnit vec2\nvar TotalSize vec2\nvar IsVertical float\n\nfunc Fragment(position vec4, texCoord vec2, color vec4) vec4 {\n\tnormColor := Color / 0xffff\n\n\tposInUnit := vec2(RectSize.x*texCoord.x, RectSize.y*texCoord.y) + RectPosInUnit\n\tif IsVertical > 0 {\n\t\t// if TotalSize.y >= TotalSize.x {\n\t\tradius := TotalSize.x / 2\n\t\t// roundCenter1 := vec2(radius)\n\t\troundCenter2 := vec2(radius, TotalSize.y-radius)\n\n\t\t// distToCenter1 := distance(posInUnit, roundCenter1)\n\t\tdistToCenter2 := distance(posInUnit, roundCenter2)\n\t\tmultiplier := clamp(TotalSize.y/radius, 0, 1)\n\n\t\t// Top Left Corner\n\t\tif (ShadedCorners[0] > 0) && (posInUnit.x < radius) &&\n\t\t\t(posInUnit.y < radius) && (posInUnit.y <= theFunc(posInUnit.x, radius, multiplier)) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Bottom Left Corner\n\t\tif (ShadedCorners[1] > 0) && (posInUnit.x < radius) &&\n\t\t\t(posInUnit.y > (TotalSize.y - radius)) && (distToCenter2 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Bottom Right Corner\n\t\tif (ShadedCorners[2] > 0) && (posInUnit.x > radius) &&\n\t\t\t(posInUnit.y > (TotalSize.y - radius)) && (distToCenter2 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Top Right Corner\n\t\tif (ShadedCorners[3] > 0) && (posInUnit.x > radius) &&\n\t\t\t(posInUnit.y < radius) && (posInUnit.y <= theFunc(posInUnit.x, radius, multiplier)) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// }\n\n\t} else {\n\t\t// if TotalSize.x >= TotalSize.y {\n\t\tradius := TotalSize.y / 2\n\t\troundCenter1 := vec2(radius)\n\t\troundCenter2 := vec2(TotalSize.x-radius, radius)\n\n\t\tdistToCenter1 := distance(posInUnit, roundCenter1)\n\t\tdistToCenter2 := distance(posInUnit, roundCenter2)\n\n\t\t// radius *= clamp((TotalSize.y / TotalSize.x), 0, 1)\n\t\t// radius = min(radius, TotalSize.x)\n\t\t// Top Left Corner\n\t\tif (ShadedCorners[0] > 0) && (posInUnit.x < radius) &&\n\t\t\t(posInUnit.y < radius) && (distToCenter1 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Bottom Left Corner\n\t\tif (ShadedCorners[1] > 0) && (posInUnit.x < radius) &&\n\t\t\t(posInUnit.y > radius) && (distToCenter1 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Bottom Right Corner\n\t\tif (ShadedCorners[2] > 0) && (posInUnit.x > TotalSize.x-radius) &&\n\t\t\t(posInUnit.y > radius) && (distToCenter2 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// Top Right Corner\n\t\tif (ShadedCorners[3] > 0) && (posInUnit.x > TotalSize.x-radius) &&\n\t\t\t(posInUnit.y < radius) && (distToCenter2 > radius) {\n\t\t\tnormColor.a = 0\n\t\t}\n\t\t// }\n\t}\n\n\tnormColor.rgb *= normColor.a\n\treturn normColor\n}\n\nfunc theFunc(x float, radius float, multiplier float) float {\n\t// if multiplier == 1 {\n\t// \treturn radius - sqrt(radius*radius-(x-radius)*(x-radius))\n\t// }\n\t// return multiplier * ( /*radius -*/ pow(x-radius, 2) / radius)\n\n\t// Linear interpolation between squared function and circle function\n\ty0 := multiplier * ( /*radius -*/ pow(x-radius, 2) / radius)\n\tx0 := 0\n\tx1 := 1\n\ty1 := radius - sqrt(radius*radius-(x-radius)*(x-radius))\n\n\treturn y0 + (multiplier-x0)*(y1-y0)/(x1-x0)\n}\n")
